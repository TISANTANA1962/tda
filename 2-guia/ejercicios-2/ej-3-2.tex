\lstset{
  mathescape=true,
  emph={[1]funcion, return, ret, retorno},
  emph={[2]para, cada, si, sino, if, else, true, false, mientras, not, y, o},
  emph={[3]meto, saco, maxSubset, max},
  emphstyle={[1]\color{violet}\it},
  emphstyle={[2]\color{red}\it},
  emphstyle={[3]\color{OliveGreen}\it},
  morecomment={[l]{//}},
  commentstyle={\color{gray}\it\footnotesize}
}
\begin{enunciado}{\ejercicio[MaxiSubconjunto]}
  \textbf{\textit{MaxiSubconjunto}}

  Dada una matriz simétrica $M$ de $n \times n$ números naturales y un número $k$, queremos encontrar un subconjunto
  $I$ de $\set{1, \ldots, n}$ con $|I| = k$ que maximice $\sum_{i,j\en I} M_{ij}$. Por ejemplo, si $k = 3$ y:
  $$
    M =
    \matriz{cccc}{
      0 & 10 & 10 & 1 \\
      - & 0 & 5 & 2 \\
      - & - & 0 & 1  \\
      - & - & - & 0 \\
    }
  $$
  entonces $I = \set{1,2,3}$ es una solución óptima.
  \begin{enumerate}[label=$\alph*)$]
    \item Diseñar un algoritmo de \textit{backtracking} para resolver el problema, indicando claramente
          cómo se codifica una solución candidata, cuáles soluciones son válidas y qué valor tienen,
          qué es una solución parcial y cómo se extiende cada solución parcial.

    \item Calcular la complejidad temporal y espacial del mismo.

    \item Proponer una poda por optimalidad y mostrar que es correcta.
  \end{enumerate}
\end{enunciado}

Tener presente que hay distintas formas de implementar estos ejercicios.
Dependiendo de como se haga pueden dar distintas complejidades. En este
caso no nos piden ninguna complejidad en particular.

\begin{enumerate}[label=$\alph*)$]
  \item Lo primero que hay que hacer es entender qué cosa piden. Luego encontrar con \textit{fuerza bruta} una solución. No es
        buena idea buscar eficiencia, \textit{hackear}, ni un choto. Fuerza bruta y recursión.

        Las \textit{soluciones candidatas} van a ser todos los intervalos que me pueda formar tomando $k$ elementos de $\set{1,\ldots, n}$,
        por ejemplo, $n=4$ y $k=2$:

        El siguiente árbol de decisión binario tiene todas las $2^4$ combinaciones que se pueden formar por fuerza bruta.
        Los \textit{bitarrays} indican en cada posición si en el conjunto está usando el elemento o no, por ejemplo:
        $$
          \intervalo{1,0,1,0} \flecha{equivale al}[conjunto] \set{1,3}
          \ytext
          \intervalo{0,1,1,1} \flecha{equivale al}[conjunto] \set{2,3,4}
        $$
        \forestset{
          binary tree/.style={
              for tree={
                  scale=0.4,
                  line width=1pt,
                  minimum size=1cm,
                  rectangle, draw,
                  math content,
                  s sep=.3cm, l sep=0.3cm,
                  edge={line width=0.5pt},
                },
              important/.style={draw=##1,line width=1.5pt,edge={##1,line width=1.5pt}},
            }
        }

        $$
          \begin{forest}
            binary tree,
            [\intervalo{0,0,0,0},
            [\intervalo{1,0,0,0},important=red
            [\intervalo{1,1,0,0},important=red
            [\intervalo{1,1,1,0},
            [\intervalo{1,1,1,1}], [\intervalo{1,1,1,0}]
            ],
            [\intervalo{1,1,0,0},important=OliveGreen
            [\intervalo{1,1,0,1}], [\intervalo{1,1,0,0},important=OliveGreen]
            ]
            ],
            [\intervalo{1,0,0,0},important=red
            [\intervalo{1,0,1,0},important=red
            [\intervalo{1,0,1,1}], [\intervalo{1,0,1,0},important=OliveGreen]
            ],
            [\intervalo{1,0,0,0},important=red
            [\intervalo{1,0,0,1},important=red], [\intervalo{1,0,0,0}]
            ]
            ]
            ],
            [\intervalo{0,0,0,0},important=red
            [\intervalo{0,1,0,0},important=red
            [\intervalo{0,1,1,0},important=red
            [\intervalo{0,1,1,1}], [\intervalo{0,1,1,0},important=OliveGreen]
            ],
            [\intervalo{0,1,0,0},important=red
            [\intervalo{0,1,0,1},important=red], [\intervalo{0,1,0,0}]
            ]
            ],
            [\intervalo{0,0,0,0},important=red
            [\intervalo{0,0,1,0},important=red
            [\intervalo{0,0,1,1},important=red], [\intervalo{0,0,1,0}]
            ],
            [\intervalo{0,0,0,0},important=violet
            [\intervalo{0,0,0,1},important=violet], [\intervalo{0,0,0,0},important=violet]
            ]
            ]
            ]
            ]
          \end{forest}
        $$
        Las hojas del \red{subárbol rojo} son las soluciones \textit{candidatas} a ser la solución al problema, dado que corresponden
        a conjuntos de tamaño $k$. Los nodos en el camino para llegar hasta esas hojas son las \textit{soluciones parciales}.

        Las soluciones \textit{válidas} serán un subconjunto de esas \red{hojas} mencionadas que maximicen $\sumatoria{i,j \en I_r}{} M_{ij}$.

        Voy a querer parar de hacer recursión si:
        \begin{itemize}
          \item Cuando se terminó un camino, cuando llegué a una hoja del árbol de recursión, cuándo el
                itervalo tiene exactamente $k$ elementos distintos, devuelvo una tupla $(I, \sum)$.

          \item La implementación arranca en un valor $l \en \set{1,\ldots,n}$, así que si $l > n$ ya
                generé todos los intervalos candidatos. Acá devuelvo una tupla, que tiene la particularidad de
                \ul{nunca} ser una respuesta válida.
        \end{itemize}
        Luego me quedo con el intervalo $I$ óptimo según la suma $\sum$ que se obtenga en la comparación.
        $$
          \green{maxSubset}(k,I,l,n)=
          \llave{ccl}{
            \big( I, \sumatoria{i,j \en I}{} M_{ij} \big)   & \text{si} & |I| = k\\
            \big(  \vacio, -\infinito \big) & \text{si} & l > n \\
            \maximo\limits_I
            \matriz{c}{
              \green{maxSubset}(k, I, l + 1, n), \\
              \green{maxSubset}(k, I \union \set{l}, l + 1, n)
            }
            & \multicolumn{2}{l}{ \text{si no} }\\
          }
        $$

  \item
        Esta función tiene 2 llamados por recursión, lo que daría una complejidad de $O(2^n)$, si bien \green{corta las ramas verdes cuando $|I| = k$}
        antes de recorrer todo el árbol, no atiende la parte \violet{violeta del árbol} abajo a la izquierda: Ahí no se detiene.
        (En el próximo inciso se soluciona eso, paciencia, cdtm)

        Cada subproblema consta de sumar $O(k^2)$ elementos de $M$.
        Por lo que resulta que el \textit{running time} es:
        $$
          \cajaResultado{
            \textstyle
            T(n) \en
            O\Big(k^2 \cdot 2^n\Big)
          }
        $$

        El árbol de recursión tiene $n$ niveles y teniendo en cuenta que $I$ se pasa por referencia tengo una complejidad espacial:
        $$
          \cajaResultado{
            \textstyle
            S(n) \en O(n)
          }
        $$

  \item
        Hay una poda importante que se puede hacer para reducir la complejidad temporal a algo polinomial y es podar \violet{las ramas violetas}
        $$
          \green{maxSubset}(k,I,l,n)=
          \llave{ccl}{
            \big( I, \sumatoria{i,j \en I}{} M_{ij} \big)   & \text{si} & |I| = k\\
            \big(  \vacio, -\infinito \big) & \text{si} & \violet{|I| + (n-l + 1) < k}\\
            \maximo\limits_I
            \matriz{c}{
              \green{maxSubset}(k, I, l + 1, n), \\
              \green{maxSubset}(k, I \union \set{l}, l + 1, n)
            }
            & \multicolumn{2}{l}{ \text{si no} }\\
          }
        $$
        Básicamente dice que si ya no quedan $k$ números para armar un intervalo de tamaño $k$, que ni lo intente y corte la recursión.

        El \textit{running time} con esta poda:
        $$
          \cajaResultado{
            \textstyle
            T(n) \en
            O\Big(k^2 \cdot \binom{n}{k}\Big)
          }
        $$
\end{enumerate}

Este mismo ejercicio se puede resolver con otra implementación, quizás más intuitiva:

\begin{enumerate}[label=$\alph*)$]
  \item
        $$
          \textstyle
          \green{maxSubset}(I, C) =
          \llave{ccl}{
            \big( I, \sumatoria{i,j \en I}{} M_{ij} \big)   & \text{si} & |I| = k\\
            \maximo\limits_{c\en C}
            \matriz{l}{
              \green{maxSubset}(I \union \set{c}, C - \set{c})
            }
            & \multicolumn{2}{l}{\text{si no}}
          }
        $$
        ¿Cuál es la diferencias? Acá el árbol de esta función tiene otra forma. No es un árbol de decisión binaria, es algo factorial,
        por ejemplo si $n=4$ y $k=3$:
        \forestset{
          binary tree/.style={
              for tree={
                  scale=0.2,
                  line width=1pt,
                  minimum size=1cm,
                  rectangle, draw,
                  math content,
                  s sep=.3cm, l sep=0.3cm,
                  edge={line width=0.5pt},
                },
              important/.style={draw=##1,line width=1pt,edge={##1,line width=0.5pt}},
            }
        }
        $$
          \begin{forest}
            binary tree,
            [\set{},important=red
            [\set{1},important=red
            [\set{1,2},important=red
            [\set{1,2,3},important=red [\set{1,2,3,4}] ],
            [\set{1,2,4},,important=red [\set{1,2,3,4}]],
            ],
            [\set{2,3},important=red ,
                [\set{1,2,3},important=red ,[\set{1,2,3,4}]],
                [\set{2,3,4},important=red ,[\set{1,2,3,4}]],
              ],
            [\set{3,4},important=red
            [\set{1,3,4},important=red ,[\set{1,2,3,4}]],
            [\set{2,3,4},important=red ,[\set{1,2,3,4}]],
            ],
            ],
            [\set{2},important=red
            [\set{1,2},important=red ,
            [\set{1,2,3},important=red , [\set{1,2,3,4}]],
            [\set{1,2,4},important=red ,[\set{1,2,3,4}]],
            ],
            [\set{2,3},important=red ,
            [\set{1,2,3},important=red [\set{1,2,3,4}]],
            [\set{2,3,4},important=red [\set{1,2,3,4}]],
            ],
            [\set{3,4},important=red
            [\set{1,3,4},important=red [\set{1,2,3,4}]],
            [\set{2,3,4},important=red [\set{1,2,3,4}]],
            ],
            ],
            [\set{3},important=red
            [\set{1,2},important=red ,
            [\set{1,2,3},important=red [\set{1,2,3,4}]],
            [\set{1,2,4},important=red [\set{1,2,3,4}]],
            ],
            [\set{2,3},important=red ,
            [\set{1,2,3},important=red [\set{1,2,3,4}]],
            [\set{2,3,4},important=red [\set{1,2,3,4}]],
            ],
            [\set{3,4},important=red
            [\set{1,3,4},important=red [\set{1,2,3,4}]],
            [\set{2,3,4},important=red [\set{1,2,3,4}]],
            ],
            ],
            [\set{4},important=red
            [\set{1,2},important=red ,
            [\set{1,2,3},important=red [\set{1,2,3,4}]],
            [\set{1,2,4},important=red [\set{1,2,3,4}]],
            ],
            [\set{2,3},important=red ,
            [\set{1,2,3},important=red [\set{1,2,3,4}]],
            [\set{2,3,4},important=red [\set{1,2,3,4}]],
            ],
            [\set{3,4},important=red
            [\set{1,3,4},important=red ,[\set{1,2,3,4}]],
            [\set{2,3,4},important=red ,[\set{1,2,3,4}]],
            ],
            ],
            ]
          \end{forest}
        $$
        Esos conjuntos que se generan seguro van a resolver el problema, pero hay que \textit{analizar la complejidad} como corresponda.

  \item
        Ese \textit{árbol rojo} tiene $\frac{n!}{(n-k)!}$ hojas. Implementado en un conjunto logarítmico que tiene un costo de agregar de $\log(n)$
        cada subproblema tiene un costo de $O(k^2 \cdot \log(k))$:
        $$
          \cajaResultado{
            T(n) = O\Big(
            \log(k) \cdot k^2 \cdot \frac{n!}{(n-k)!}
            \Big)
          }
        $$

        La complejidad espacial de una recursión de $n$ niveles donde tengo a $I$ y a $C$, en el caso de que $I$ se pasa por referencia:
        $$
          \cajaResultado{
            S(n) \en O(k^2)
          }
        $$

  \item Parecido a lo que se hizo en la implementación anterior, podría ahorrar tiempo guardando la suma parcial de cada intervalo.
        El hecho de que haya millones de subproblemas iguales me lleva la cabeza a \textit{programación dinámica}, pero hay que
        ser pacientes.
\end{enumerate}

\bigskip

\parrafoDestacado[\red{\faIcon{code}}]{
  Y acá un pseudocódigo en imperativo para pasarlo a tu lenguaje favorito un poco más friendly
    {\color{gray}\tiny(si tu lenguaje favorito es Haskell, hacete ver)} de la \ul{primera} implementación:
}

\begin{tcolorbox}
  \begin{lstlisting}
      funcion maxSubset(r,k,I,l,n)
          si |I|=k
              ret {I,$\sumatoria{\texttt{i,j} \en \texttt{I}}{}$ M[i,j]}
          si |I|+(n-l+1)<k
              ret {$\vacio$, -$\infty$}
          máximo $\ot$ -$\infty$
          //   Arranca rama que usa l
          I.meto(l)
          máximo $\ot$ max(máximo, maxSubset(r+1,k,I,l+1,n)[2])
          // Arranca rama que NO usa l
          I.saco(l) 
          máximo $\ot$ max(máximo,maxSubset(r+1,k,I,l+1,n)[2])
          ret {I,máximo} \end{lstlisting}
\end{tcolorbox}
